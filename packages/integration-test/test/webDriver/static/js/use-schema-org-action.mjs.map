{"version":3,"sources":["../src/ActionStatusType.ts","../src/PropertyValueSpecificationSchema.ts","../src/toURLSearchParams.ts","../src/toURLTemplateData.ts","../src/useSchemaOrgAction.ts","../src/private/buildSchemaFromConstraintsRecursive.ts","../src/private/isPlainObject.ts","../src/private/mergeActionStateRecursive.ts","../src/private/extractActionStateFromAction.ts","../src/private/extractVariablesFromActionStateRecursive.ts","../src/private/validateConstraints.ts"],"sourcesContent":["import { picklist, type InferOutput } from 'valibot';\n\n/** Validation schema for `ActionStatusType`. */\nconst actionStatusTypeSchema = picklist([\n  'ActiveActionStatus',\n  'CompletedActionStatus',\n  'FailedActionStatus',\n  'PotentialActionStatus'\n]);\n\n/** Indicates the current disposition of the [Action](https://schema.org/Action). */\ntype ActionStatusType = InferOutput<typeof actionStatusTypeSchema>;\n\nexport { actionStatusTypeSchema, type ActionStatusType };\n","import {\n  array,\n  boolean,\n  custom,\n  date,\n  instance,\n  literal,\n  maxLength,\n  maxValue,\n  minLength,\n  minValue,\n  number,\n  object,\n  optional,\n  parse,\n  picklist,\n  pipe,\n  regex,\n  safeParse,\n  string,\n  transform,\n  union,\n  type ArraySchema,\n  type BaseIssue,\n  type BaseSchema,\n  type InferOutput,\n  type PipeItem,\n  type SchemaWithPipe\n} from 'valibot';\n\nconst propertyValueSpecificationObjectSchema = object({\n  '@type': optional(pipe(string(), literal('PropertyValueSpecification', 'Must be \"PropertyValueSpecification\"'))),\n  defaultValue: optional(union([date(), number(), string()])),\n  maxValue: optional(union([date(), number(), string()])),\n  minValue: optional(union([date(), number(), string()])),\n  multipleValues: optional(boolean()),\n  stepValue: optional(union([number(), string()])),\n  valueMaxLength: optional(union([number(), string()])),\n  valueMinLength: optional(union([number(), string()])),\n  valueName: optional(string()),\n  valuePattern: optional(instance(RegExp)),\n  valueRequired: optional(boolean())\n});\n\nconst propertyValueSpecificationStringSchema = pipe(\n  string(),\n  transform<string, InferOutput<typeof propertyValueSpecificationObjectSchema>>(value => {\n    const spec: Partial<InferOutput<typeof propertyValueSpecificationObjectSchema>> = {};\n\n    const specMap = new Map(\n      parse(string(), value)\n        .split(/\\s+/g)\n        .map((token): [string, string] => {\n          // Split must have at least 1 token.\n          const name = token.split('=', 1)[0] as string;\n\n          return [name, token.slice(name.length + 1)];\n        })\n    );\n\n    const name = specMap.get('name');\n\n    if (typeof name !== 'undefined') {\n      spec.valueName = name;\n    }\n\n    const maxValue = specMap.get('max');\n\n    if (typeof maxValue !== 'undefined') {\n      spec.maxValue = maxValue;\n    }\n\n    const maxLength = specMap.get('maxlength');\n\n    if (typeof maxLength !== 'undefined') {\n      spec.valueMaxLength = maxLength;\n    }\n\n    const minValue = specMap.get('min');\n\n    if (typeof minValue !== 'undefined') {\n      spec.minValue = minValue;\n    }\n\n    const minLength = specMap.get('minlength');\n\n    if (typeof minLength !== 'undefined') {\n      spec.valueMinLength = minLength;\n    }\n\n    if (specMap.has('multiple')) {\n      spec.multipleValues = true;\n    }\n\n    if (specMap.has('pattern')) {\n      spec.valuePattern = parse(\n        pipe(\n          string(),\n          transform(input => new RegExp(input))\n        ),\n        specMap.get('pattern')\n      );\n    }\n\n    if (specMap.has('required')) {\n      spec.valueRequired = true;\n    }\n\n    const stepValue = specMap.get('step');\n\n    if (typeof stepValue !== 'undefined') {\n      spec.stepValue = stepValue;\n    }\n\n    const defaultValue = specMap.get('value');\n\n    if (typeof defaultValue !== 'undefined') {\n      spec.defaultValue = `${specMap.get('value')}`;\n    }\n\n    return parse(propertyValueSpecificationObjectSchema, spec);\n  })\n);\n\n/** Validation schema for `PropertyValueSpecification`. */\nconst propertyValueSpecificationSchema = union([\n  propertyValueSpecificationObjectSchema,\n  propertyValueSpecificationStringSchema\n]);\n\ntype MySchema<T> =\n  | BaseSchema<T | undefined, T | undefined, BaseIssue<unknown>>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | SchemaWithPipe<[BaseSchema<T | undefined, T | undefined, any>, PipeItem<any, T, any>]>\n  | ArraySchema<\n      | BaseSchema<T | undefined, T | undefined, BaseIssue<unknown>>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | SchemaWithPipe<[BaseSchema<T | undefined, T | undefined, any>, PipeItem<any, T, any>]>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      any\n    >;\n\n/**\n * Converts an instance of `PropertyValueSpecification` into a validation schema.\n *\n * @param propertyValueSpecification An instance of `PropertyValueSpecification` to convert from.\n * @param choices A list of values to choose from for the value. An empty array will allow any values.\n * @returns A validation schema.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction toValibotSchema(propertyValueSpecification: PropertyValueSpecification, choices: any[] = []) {\n  if (typeof propertyValueSpecification === 'string') {\n    propertyValueSpecification = parse(propertyValueSpecificationStringSchema, propertyValueSpecification);\n  }\n\n  let dateSchema: MySchema<Date> = date();\n  let numberSchema: MySchema<number> = number();\n  let stringSchema: MySchema<string> = string();\n\n  const { defaultValue } = propertyValueSpecification;\n\n  if (defaultValue instanceof Date) {\n    dateSchema = optional(dateSchema, defaultValue);\n  } else if (typeof defaultValue === 'number') {\n    numberSchema = optional(numberSchema, defaultValue);\n  } else if (typeof defaultValue === 'string') {\n    stringSchema = optional(stringSchema, defaultValue);\n  } else if (!propertyValueSpecification.valueRequired) {\n    dateSchema = optional(dateSchema);\n    numberSchema = optional(numberSchema);\n    stringSchema = optional(stringSchema);\n  }\n\n  if (propertyValueSpecification.maxValue instanceof Date) {\n    dateSchema = pipe(dateSchema, maxValue(propertyValueSpecification.maxValue));\n  } else if (typeof propertyValueSpecification.maxValue === 'number') {\n    dateSchema = pipe(dateSchema, maxValue(new Date(propertyValueSpecification.maxValue)));\n    numberSchema = pipe(numberSchema, maxValue(propertyValueSpecification.maxValue));\n  } else if (typeof propertyValueSpecification.maxValue === 'string') {\n    const parseDateResult = safeParse(htmlStringDate, propertyValueSpecification.maxValue);\n\n    if (parseDateResult.success) {\n      dateSchema = pipe(dateSchema, maxValue(parseDateResult.output));\n    }\n\n    const parseNumberResult = safeParse(htmlStringNumber, propertyValueSpecification.maxValue);\n\n    if (parseNumberResult.success) {\n      numberSchema = pipe(numberSchema, maxValue(parseNumberResult.output));\n    }\n  }\n\n  // TODO: Dedupe the code with maxValue.\n  if (propertyValueSpecification.minValue instanceof Date) {\n    dateSchema = pipe(dateSchema, minValue(propertyValueSpecification.minValue));\n  } else if (typeof propertyValueSpecification.minValue === 'number') {\n    dateSchema = pipe(dateSchema, minValue(new Date(propertyValueSpecification.minValue)));\n    numberSchema = pipe(numberSchema, minValue(propertyValueSpecification.minValue));\n  } else if (typeof propertyValueSpecification.minValue === 'string') {\n    const parseDateResult = safeParse(htmlStringDate, propertyValueSpecification.minValue);\n\n    if (parseDateResult.success) {\n      dateSchema = pipe(dateSchema, minValue(parseDateResult.output));\n    }\n\n    const parseNumberResult = safeParse(htmlStringNumber, propertyValueSpecification.minValue);\n\n    if (parseNumberResult.success) {\n      numberSchema = pipe(numberSchema, minValue(parseNumberResult.output));\n    }\n  }\n\n  const { stepValue } = propertyValueSpecification;\n\n  if (typeof stepValue === 'number') {\n    numberSchema = pipe(\n      numberSchema,\n      custom(value => typeof value === 'number' && value % stepValue === 0)\n    );\n\n    dateSchema = pipe(\n      dateSchema,\n      custom(value => value instanceof Date && +value % stepValue === 0)\n    );\n  } else if (typeof stepValue === 'string') {\n    const stepValueAsNumber = parse(htmlStringNumber, stepValue);\n\n    numberSchema = pipe(\n      numberSchema,\n      custom(value => typeof value === 'number' && value % stepValueAsNumber === 0)\n    );\n\n    dateSchema = pipe(\n      dateSchema,\n      custom(value => value instanceof Date && +value % stepValueAsNumber === 0)\n    );\n  }\n\n  if (typeof propertyValueSpecification.valuePattern !== 'undefined') {\n    stringSchema = pipe(stringSchema, regex(propertyValueSpecification.valuePattern));\n  }\n\n  if (typeof propertyValueSpecification.valueMaxLength === 'number') {\n    stringSchema = pipe(stringSchema, maxLength(propertyValueSpecification.valueMaxLength));\n  } else if (typeof propertyValueSpecification.valueMaxLength === 'string') {\n    stringSchema = pipe(stringSchema, maxLength(parse(htmlStringNumber, propertyValueSpecification.valueMaxLength)));\n  }\n\n  if (typeof propertyValueSpecification.valueMinLength === 'number') {\n    stringSchema = pipe(stringSchema, minLength(propertyValueSpecification.valueMinLength));\n  } else if (typeof propertyValueSpecification.valueMinLength === 'string') {\n    stringSchema = pipe(stringSchema, minLength(parse(htmlStringNumber, propertyValueSpecification.valueMinLength)));\n  }\n\n  if (choices.length) {\n    dateSchema = pipe(dateSchema, picklist(choices));\n    numberSchema = pipe(numberSchema, picklist(choices));\n    stringSchema = pipe(stringSchema, picklist(choices));\n  }\n\n  if (propertyValueSpecification.multipleValues) {\n    dateSchema = array(dateSchema);\n    numberSchema = array(numberSchema);\n    stringSchema = array(stringSchema);\n  }\n\n  return union([dateSchema, numberSchema, stringSchema]);\n}\n\nconst htmlStringDate = pipe(\n  string(),\n  // TODO: Currently, we require a date component.\n  //       We should follow HTML date parsing algorithm, https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#dates-and-times.\n  regex(/^\\d{1,}-(0?1|0?2|0?3|0?4|0?5|0?6|0?7|0?8|0?9|10|11|12)-{0,3}\\d/),\n  transform<string, Date>(input => new Date(input)),\n  custom<Date>(input => !isNaN(+(input as Date)))\n);\n\nconst htmlStringNumber = pipe(\n  string(),\n  // TODO: parseInt() does not strictly follow HTML number parsing algorithm.\n  //       We should follow HTML number parsing algorithm, https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#numbers.\n  regex(/^-?\\d+(\\.\\d*)?$/),\n  transform<string, number>(input => parseInt(input, 10))\n);\n\n/** Validation schema for `PropertyValueSpecification`. */\nexport default propertyValueSpecificationSchema;\n\n/** A Property value specification. */\nexport type PropertyValueSpecification = InferOutput<typeof propertyValueSpecificationObjectSchema> | string;\n\nexport { toValibotSchema };\n","import { type VariableMap } from './VariableMap.ts';\n\n/**\n * Converts `Map` of variables into `URLSearchParams`.\n *\n * - `boolean` and `number` will be converted to string\n * - `Date` will be converted by its `toISOString()` function\n * - `null` and `undefined` will be converted to empty string\n * - Other types will be converted by their `toString()` function\n *\n * @param variableMap Variables to convert.\n * @returns {URLSearchParams}\n */\nexport default function toURLSearchParams(variableMap: VariableMap): URLSearchParams {\n  return new URLSearchParams(\n    Array.from(\n      variableMap\n        .entries()\n        .map(([key, value]): [string, string] => [\n          key,\n          typeof value === 'undefined' || value === null\n            ? ''\n            : typeof value === 'object' && 'toLocaleString' in value\n              ? `${value.toISOString()}`\n              : `${value}`\n        ])\n    )\n  );\n}\n","import toURLSearchParams from './toURLSearchParams.ts';\nimport { type VariableMap } from './VariableMap.ts';\n\n/**\n * Converts `Map` of variables into object of strings.\n *\n * - `boolean` and `number` will be converted to string\n * - `Date` will be converted by its `toISOString()` function\n * - `null` and `undefined` will be converted to empty string\n * - Other types will be converted by their `toString()` function\n *\n * The return value can be passed to [`url-template`](https://npmjs.com/package/url-template) package.\n *\n * @param variableMap `Map` of variables to convert into object of strings.\n * @returns {Record<string, string[]>}\n */\nexport default function toURLTemplateData(variableMap: VariableMap): Record<string, string[]> {\n  const expandables: Record<string, string[]> = {};\n\n  toURLSearchParams(variableMap).forEach((value, key) => (expandables[key] = expandables[key] || []).push(value));\n\n  return expandables;\n}\n","import { useCallback, useEffect, useMemo, useRef, useState, type Dispatch, type SetStateAction } from 'react';\nimport { useRefFrom } from 'use-ref-from';\nimport {\n  fallback,\n  object,\n  optional,\n  parse,\n  type ErrorMessage,\n  type ObjectEntries,\n  type ObjectIssue,\n  type ObjectSchema\n} from 'valibot';\nimport { type ActionHandler } from './ActionHandler.ts';\nimport { type ActionState } from './ActionState.ts';\nimport { actionStatusTypeSchema } from './ActionStatusType.ts';\nimport buildSchemaFromConstraintsRecursive from './private/buildSchemaFromConstraintsRecursive.ts';\nimport extractActionStateFromAction from './private/extractActionStateFromAction.ts';\nimport extractVariablesFromActionStateRecursive from './private/extractVariablesFromActionStateRecursive.ts';\nimport mergeActionStateRecursive from './private/mergeActionStateRecursive.ts';\nimport validateConstraints from './private/validateConstraints.ts';\nimport { type VariableMap } from './VariableMap.ts';\n\n/**\n * Returns a stateful action state, a function to update it, and a function to perform the action.\n *\n * Action state contains only input/output properties and [`actionStatus` property](https://schema.org/actionStatus).\n *\n * @param initialAction Action which the action state is based on.\n * @param onPerform Function to call when the action is being performed.\n * @returns Returns a stateful action state, a function to update it, and a function to perform the action.\n */\nexport default function useSchemaOrgAction<T extends object = object>(\n  /** Initial action which the action state is based on. */\n  initialAction: T,\n  /** Function to call when the action is performed. */\n  onPerform: ActionHandler\n): readonly [\n  /** A stateful action state. */\n  ActionState,\n  /** A function to update the action state. */\n  Dispatch<SetStateAction<ActionState>>,\n  Readonly<{\n    /** `Map` of named input properties. */\n    inputVariables: VariableMap;\n    /** Validity of the input properties. */\n    inputValidity: ValidityState;\n    /** Validation schema for input properties. */\n    inputSchema: ObjectSchema<ObjectEntries, ErrorMessage<ObjectIssue> | undefined>;\n    /** Validation schema for output properties. */\n    outputSchema: ObjectSchema<ObjectEntries, ErrorMessage<ObjectIssue> | undefined>;\n    /** A function to perform the action. */\n    perform: () => Promise<void>;\n  }>\n] {\n  const [actionState, setActionState] = useState<ActionState>(() => ({\n    ...extractActionStateFromAction(initialAction),\n    actionStatus: parse(\n      fallback(actionStatusTypeSchema, 'PotentialActionStatus'),\n      'actionStatus' in initialAction && initialAction.actionStatus\n    )\n  }));\n  const abortController = useMemo(() => new AbortController(), []);\n  const initialActionRef = useRef(initialAction);\n  const onPerformRef = useRefFrom(onPerform);\n\n  const actionStateRef = useRefFrom(actionState);\n  const inputSchema = useMemo(\n    () => buildSchemaFromConstraintsRecursive(initialActionRef.current, 'input'),\n    [initialActionRef]\n  );\n  const outputSchema = useMemo(\n    () => buildSchemaFromConstraintsRecursive(initialActionRef.current, 'output'),\n    [initialActionRef]\n  );\n\n  const inputSchemaRef = useRefFrom(inputSchema);\n  const inputValidity = useMemo(() => validateConstraints(inputSchema, actionState), [actionState, inputSchema]);\n  const outputSchemaRef = useRefFrom(outputSchema);\n\n  const perform = useCallback<() => Promise<void>>(async () => {\n    if (!validateConstraints(inputSchemaRef.current, actionStateRef.current).valid) {\n      setActionState(actionState => ({ ...actionState, actionStatus: 'FailedActionStatus' }));\n\n      return Promise.reject(Error('Input is invalid, cannot submit.'));\n    }\n\n    setActionState(actionState => ({ ...actionState, actionStatus: 'ActiveActionStatus' }));\n\n    let response: ActionState;\n\n    try {\n      const inputVariables = extractVariablesFromActionStateRecursive(\n        initialActionRef.current,\n        actionStateRef.current,\n        'input'\n      );\n\n      // TODO: Refactor to extractInputPropertiesFromActionStateRecursive helper.\n      const request = mergeActionStateRecursive(initialActionRef.current, {}, actionStateRef.current, 'input');\n\n      response = await onPerformRef.current(request, inputVariables, { signal: abortController.signal });\n\n      try {\n        parse(outputSchema, response);\n\n        // If \"actionStatus-output\" is defined, validate \"actionStatus\" property in the response.\n        // Otherwise, do not validate the property.\n        if ('actionStatus-output' in initialActionRef.current) {\n          parse(object({ actionStatus: optional(actionStatusTypeSchema) }), response);\n        }\n      } catch (cause) {\n        const error = new Error('Output is invalid.');\n\n        error.cause = cause;\n\n        throw error;\n      }\n\n      if (abortController.signal.aborted) {\n        return;\n      }\n    } catch (error) {\n      if (!abortController.signal.aborted) {\n        setActionState(actionState => ({ ...actionState, actionStatus: 'FailedActionStatus' }));\n      }\n\n      throw error;\n    }\n\n    setActionState(actionState =>\n      mergeActionStateRecursive(\n        initialActionRef.current,\n        { ...actionState, actionStatus: 'CompletedActionStatus' },\n        response,\n        'output'\n      )\n    );\n  }, [\n    abortController,\n    actionStateRef,\n    initialActionRef,\n    inputSchemaRef,\n    onPerformRef,\n    outputSchemaRef,\n    setActionState\n  ]);\n\n  const inputVariables = useMemo(\n    () => extractVariablesFromActionStateRecursive(initialActionRef.current, actionState, 'input'),\n    [actionState, initialActionRef]\n  );\n\n  const options = useMemo(\n    () =>\n      Object.freeze({\n        inputSchema,\n        inputValidity,\n        inputVariables,\n        outputSchema,\n        perform\n      }),\n    [inputSchema, inputValidity, inputVariables, outputSchema, perform]\n  );\n\n  useEffect(() => () => abortController.abort(), [abortController]);\n\n  return useMemo(\n    () => Object.freeze([actionState, setActionState, options] as const),\n    [actionState, options, setActionState]\n  );\n}\n\nexport { type ActionHandler };\n","import { object, type ErrorMessage, type ObjectEntries, type ObjectIssue, type ObjectSchema } from 'valibot';\nimport { toValibotSchema } from '../PropertyValueSpecificationSchema.ts';\nimport isPlainObject from './isPlainObject.ts';\n\nfunction buildSchemaFromConstraintsRecursiveInternal<T extends object>(\n  action: T,\n  mode: 'input' | 'output'\n): ObjectSchema<ObjectEntries, ErrorMessage<ObjectIssue> | undefined> | undefined {\n  const objectEntriesSchema: ObjectEntries = {};\n\n  for (const [key, value] of Object.entries(action)) {\n    if (mode === 'input' && key.endsWith('-input')) {\n      const unprefixedKey = key.slice(0, -6);\n      const unprefixedValue = isPlainObject(action) && action[unprefixedKey];\n\n      objectEntriesSchema[unprefixedKey] = toValibotSchema(\n        value,\n        Array.isArray(unprefixedValue) ? unprefixedValue : undefined\n      );\n    } else if (mode === 'output' && key.endsWith('-output')) {\n      const unprefixedKey = key.slice(0, -7);\n      const unprefixedValue = isPlainObject(action) && action[unprefixedKey];\n\n      objectEntriesSchema[unprefixedKey] = toValibotSchema(\n        value,\n        Array.isArray(unprefixedValue) ? unprefixedValue : undefined\n      );\n    } else if (isPlainObject(value)) {\n      const schema = buildSchemaFromConstraintsRecursiveInternal(value, mode);\n\n      if (schema) {\n        objectEntriesSchema[key] = schema;\n      }\n    }\n  }\n\n  return Object.entries(objectEntriesSchema).length ? object(objectEntriesSchema) : undefined;\n}\n\nexport default function buildSchemaFromConstraintsRecursive<T extends object>(\n  action: T,\n  mode: 'input' | 'output'\n): ObjectSchema<ObjectEntries, ErrorMessage<ObjectIssue> | undefined> {\n  return buildSchemaFromConstraintsRecursiveInternal(action, mode) || object({});\n}\n","import _isPlainObject from 'lodash/isPlainObject';\n\nexport default function isPlainObject(object: unknown): object is Record<string, unknown> {\n  return _isPlainObject(object);\n}\n","import isPlainObject from './isPlainObject.ts';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ActionState = Record<string, any>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction mergeActionStateRecursiveInternal<T extends Record<string, any>>(\n  action: T,\n  base: ActionState | undefined,\n  update: ActionState | undefined,\n  mode: 'input' | 'output'\n): ActionState | undefined {\n  const nextActionState: ActionState = base ? { ...base } : {};\n\n  for (const [key, value] of Object.entries(action)) {\n    if (mode === 'input' && key.endsWith('-input')) {\n      const unprefixedKey = key.slice(0, -6);\n\n      nextActionState[unprefixedKey] = update?.[unprefixedKey] ?? base?.[unprefixedKey];\n    } else if (mode === 'output' && key.endsWith('-output')) {\n      const unprefixedKey = key.slice(0, -7);\n\n      nextActionState[unprefixedKey] = update?.[unprefixedKey] ?? base?.[unprefixedKey];\n    } else if (isPlainObject(value)) {\n      const subValue = mergeActionStateRecursiveInternal(value, base?.[key], update?.[key], mode);\n\n      if (typeof subValue !== 'undefined') {\n        nextActionState[key] = subValue;\n      }\n    }\n  }\n\n  return Object.entries(nextActionState).length ? nextActionState : undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport default function mergeActionStateRecursive<T extends Record<string, any>>(\n  action: T,\n  base: ActionState | undefined,\n  update: ActionState | undefined,\n  mode: 'input' | 'output'\n): ActionState {\n  return mergeActionStateRecursiveInternal<T>(action, base, update, mode) || {};\n}\n","import { type ActionState } from '../ActionState.ts';\nimport mergeActionStateRecursive from './mergeActionStateRecursive.ts';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport default function extractActionStateFromAction<T extends Record<string, any>>(action: T): ActionState {\n  return mergeActionStateRecursive(action, mergeActionStateRecursive(action, {}, action, 'input'), action, 'output');\n}\n","import { parse } from 'valibot';\nimport { type ActionState } from '../ActionState.ts';\nimport propertyValueSpecificationSchema from '../PropertyValueSpecificationSchema.ts';\nimport { type VariableMap } from '../VariableMap.ts';\nimport isPlainObject from './isPlainObject.ts';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport default function extractVariablesFromActionStateRecursive<T extends Record<string, any>>(\n  action: T,\n  actionState: ActionState | undefined,\n  mode: 'input' | 'output'\n): VariableMap {\n  const variables = new Map<string, unknown>();\n\n  for (const [key, value] of Object.entries(action)) {\n    if (mode === 'input' && key.endsWith('-input')) {\n      const unprefixedKey = key.slice(0, -6);\n\n      const { valueName } = parse(propertyValueSpecificationSchema, value);\n\n      if (typeof valueName !== 'undefined') {\n        variables.set(valueName, actionState?.[unprefixedKey]);\n      }\n    } else if (mode === 'output' && key.endsWith('-output')) {\n      const unprefixedKey = key.slice(0, -7);\n\n      const { valueName } = parse(propertyValueSpecificationSchema, value);\n\n      if (typeof valueName !== 'undefined') {\n        variables.set(valueName, actionState?.[unprefixedKey]);\n      }\n    } else if (isPlainObject(value)) {\n      for (const entry of extractVariablesFromActionStateRecursive(action[key], actionState?.[key], mode)) {\n        variables.set(entry[0], entry[1]);\n      }\n    }\n  }\n\n  return variables;\n}\n","import { safeParse, type ErrorMessage, type ObjectEntries, type ObjectIssue, type ObjectSchema } from 'valibot';\n\nexport default function validateConstraints(\n  schema: ObjectSchema<ObjectEntries, ErrorMessage<ObjectIssue> | undefined>,\n  actionState: unknown\n): Readonly<ValidityState> {\n  // TODO: Should implement ValidityState with multiple issues.\n  //       https://developer.mozilla.org/en-US/docs/Web/API/ValidityState\n  const { success } = safeParse(schema, actionState);\n\n  return Object.freeze({\n    badInput: false,\n    customError: !success,\n    patternMismatch: false,\n    rangeOverflow: false,\n    rangeUnderflow: false,\n    stepMismatch: false,\n    tooLong: false,\n    tooShort: false,\n    typeMismatch: false,\n    valid: success,\n    valueMissing: false\n  } satisfies ValidityState);\n}\n"],"mappings":"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","names":["picklist","name","maxValue","maxLength","minValue","minLength","object","optional","parse","object","object","object","parse","parse","safeParse","parse","actionState","inputVariables","object","optional"]}